use rabbitmesh_macros::{service_definition, service_method};
use serde::{Deserialize, Serialize};
use tracing::info;

#[derive(Debug, Serialize, Deserialize)]
pub struct User {
    pub id: u32,
    pub name: String,
}

#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
}

#[service_definition]
pub struct UserService;

impl UserService {
    #[service_method("GET /users/:id")]
    pub async fn get_user(user_id: u32) -> Result<User, String> {
        info!("Getting user with ID: {}", user_id);
        Ok(User { id: user_id, name: "John Doe".to_string() })
    }
    
    #[service_method("POST /users")]
    pub async fn create_user(data: CreateUserRequest) -> Result<User, String> {
        info!("Creating user with name: {}", data.name);
        Ok(User { id: 1, name: data.name })
    }

    #[service_method]
    pub async fn ping() -> Result<String, String> {
        Ok("pong".to_string())
    }

    /// Manual handler registration - will be auto-generated by macros later
    pub async fn register_handlers(service: &rabbitmesh::MicroService) -> Result<(), Box<dyn std::error::Error>> {
        use rabbitmesh::{Message, RpcResponse};
        
        // Register get_user handler
        service.register_function("get_user", move |msg: Message| {
            async move {
                Ok(match msg.deserialize_payload::<u32>() {
                    Ok(user_id) => {
                        match Self::get_user(user_id).await {
                            Ok(result) => RpcResponse::success(result, 0).unwrap(),
                            Err(err) => RpcResponse::error(&err),
                        }
                    }
                    Err(e) => RpcResponse::error(&format!("Deserialization error: {}", e)),
                })
            }
        }).await;

        // Register create_user handler
        service.register_function("create_user", move |msg: Message| {
            async move {
                Ok(match msg.deserialize_payload::<CreateUserRequest>() {
                    Ok(data) => {
                        match Self::create_user(data).await {
                            Ok(result) => RpcResponse::success(result, 0).unwrap(),
                            Err(err) => RpcResponse::error(&err),
                        }
                    }
                    Err(e) => RpcResponse::error(&format!("Deserialization error: {}", e)),
                })
            }
        }).await;

        // Register ping handler (no parameters)
        service.register_function("ping", move |_msg: Message| {
            async move {
                Ok(match Self::ping().await {
                    Ok(result) => RpcResponse::success(result, 0).unwrap(),
                    Err(err) => RpcResponse::error(&err),
                })
            }
        }).await;

        info!("âœ… All service methods registered");
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    info!("ðŸš€ Starting Test Macro Service");
    info!("Service name: {}", UserService::service_name());
    
    let service = UserService::create_service("amqp://localhost:5672").await?;
    
    info!("âœ… Service created and handlers registered");
    info!("ðŸŽ¯ Listening on RabbitMQ queue: rabbitmesh.{}", UserService::service_name());
    
    service.start().await?;
    Ok(())
}